// lib/insightsCache.ts
// In-memory cache for pre-generated AI insights
// Populated by cron job every 6 hours, served instantly to users
// Falls back to on-demand generation on cold start

import { saveCacheToBlob, loadCacheFromBlob } from './blobPersistence';

export interface CachedInsight {
  type: 'predictive' | 'anomaly' | 'comparison' | 'recommendation' | 'summary';
  severity: 'info' | 'warning' | 'critical';
  title: string;
  body: string;
  waterbody?: string;
  timeframe?: string;
}

export interface CacheEntry {
  insights: CachedInsight[];
  generatedAt: string;
  signalsHash: string; // hash of signals data — only regenerate if this changes
  provider: string;
  urgentRefresh?: boolean; // true if generated by urgent cron due to active crisis
  enrichmentSummary?: string; // e.g. "2 critical USGS alerts, 1 beach closure"
}

type CacheKey = string; // format: "STATE:ROLE" e.g. "MD:MS4"

// ─── State ───────────────────────────────────────────────────────────────────

const cache = new Map<CacheKey, CacheEntry>();
let lastFullBuild: string | null = null;
let buildInProgress = false;
let _buildStartedAt = 0;
const BUILD_LOCK_TIMEOUT_MS = 12 * 60 * 1000; // 12 min — auto-clear stale locks

// ─── Disk Persistence (debounced — max once per 10s) ────────────────────────

let _diskLoaded = false;
let _savePending = false;
let _lastSaveTime = 0;
const SAVE_DEBOUNCE_MS = 10_000;

function loadFromDisk(): boolean {
  try {
    if (typeof process === 'undefined') return false;
    const fs = require('fs');
    const path = require('path');
    const file = path.join(process.cwd(), '.cache', 'ai-insights.json');
    if (!fs.existsSync(file)) return false;
    const raw = fs.readFileSync(file, 'utf-8');
    const data = JSON.parse(raw);
    if (!data?.entries || !Array.isArray(data.entries)) return false;

    cache.clear();
    for (const [key, entry] of data.entries) {
      cache.set(key, entry);
    }
    lastFullBuild = data.lastFullBuild || null;

    console.log(
      `[Insights Cache] Loaded from disk (${cache.size} entries, ` +
      `last build ${lastFullBuild || 'unknown'})`
    );
    return true;
  } catch {
    return false;
  }
}

function saveToDisk(): void {
  try {
    if (typeof process === 'undefined' || cache.size === 0) return;
    const fs = require('fs');
    const path = require('path');
    const dir = path.join(process.cwd(), '.cache');
    const file = path.join(dir, 'ai-insights.json');
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    const payload = JSON.stringify({
      lastFullBuild,
      entries: Array.from(cache.entries()),
    });
    fs.writeFileSync(file, payload, 'utf-8');
    const sizeMB = (Buffer.byteLength(payload) / 1024 / 1024).toFixed(1);
    console.log(`[Insights Cache] Saved to disk (${sizeMB}MB, ${cache.size} entries)`);
  } catch {
    // Disk save is optional — fail silently
  }
}

function debouncedSaveToDisk(): void {
  const now = Date.now();
  if (now - _lastSaveTime >= SAVE_DEBOUNCE_MS) {
    _lastSaveTime = now;
    saveToDisk();
  } else if (!_savePending) {
    _savePending = true;
    setTimeout(() => {
      _savePending = false;
      _lastSaveTime = Date.now();
      saveToDisk();
    }, SAVE_DEBOUNCE_MS - (now - _lastSaveTime));
  }
}

function ensureDiskLoaded() {
  if (!_diskLoaded) {
    _diskLoaded = true;
    loadFromDisk();
  }
}

let _blobChecked = false;
export async function ensureWarmed(): Promise<void> {
  ensureDiskLoaded();
  if (cache.size > 0) return;
  if (_blobChecked) return;
  _blobChecked = true;
  const data = await loadCacheFromBlob<{ lastFullBuild: string | null; entries: [string, CacheEntry][] }>('cache/insights.json');
  if (data?.entries && Array.isArray(data.entries)) {
    cache.clear();
    for (const [key, entry] of data.entries) {
      cache.set(key, entry);
    }
    lastFullBuild = data.lastFullBuild || null;
    console.warn(`[Insights Cache] Loaded from blob (${cache.size} entries, last build ${lastFullBuild || 'unknown'})`);
  }
}

// ─── Helpers ─────────────────────────────────────────────────────────────────

export function getCacheKey(state: string, role: string): CacheKey {
  return `${state.toUpperCase()}:${role}`;
}

// Simple hash for change detection — if signals haven't changed, skip regeneration
export function hashSignals(signals: any[]): string {
  const str = JSON.stringify(signals.map(s => `${s.type}:${s.severity}:${s.title}`).sort());
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash |= 0;
  }
  return hash.toString(36);
}

// ─── Public API ──────────────────────────────────────────────────────────────

export function getInsights(state: string, role: string): CacheEntry | null {
  ensureDiskLoaded();
  const entry = cache.get(getCacheKey(state, role));
  if (!entry) return null;

  // Stale after 7 hours (gives buffer past 6hr cron)
  const age = Date.now() - new Date(entry.generatedAt).getTime();
  if (age > 7 * 60 * 60 * 1000) return null;

  return entry;
}

export function setInsights(state: string, role: string, entry: CacheEntry): void {
  cache.set(getCacheKey(state, role), entry);
  debouncedSaveToDisk();
}

export function isBuildInProgress(): boolean {
  if (buildInProgress && _buildStartedAt > 0 && Date.now() - _buildStartedAt > BUILD_LOCK_TIMEOUT_MS) {
    console.warn('[Insights Cache] Auto-clearing stale build lock (>12 min)');
    buildInProgress = false;
    _buildStartedAt = 0;
  }
  return buildInProgress;
}

export function setBuildInProgress(v: boolean): void {
  buildInProgress = v;
  _buildStartedAt = v ? Date.now() : 0;
}

export async function setLastFullBuild(timestamp: string): Promise<void> {
  lastFullBuild = timestamp;
  saveToDisk(); // Force immediate save at end of build
  await saveCacheToBlob('cache/insights.json', {
    lastFullBuild,
    entries: Array.from(cache.entries()),
  });
}

export function getCacheStatus(): {
  status: 'idle' | 'building' | 'ready';
  entries: number;
  lastFullBuild: string | null;
  states: string[];
} {
  ensureDiskLoaded();
  const states = new Set<string>();
  for (const key of cache.keys()) {
    states.add(key.split(':')[0]);
  }
  return {
    status: buildInProgress ? 'building' : cache.size > 0 ? 'ready' : 'idle',
    entries: cache.size,
    lastFullBuild,
    states: [...states].sort(),
  };
}

// Clear all cached insights (for manual reset)
export function clearInsightsCache(): void {
  cache.clear();
  lastFullBuild = null;
}
