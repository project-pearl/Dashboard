import jsPDF from 'jspdf';

export interface PDFContentSection {
  title?: string;
  content: string[];
  table?: {
    headers: string[];
    rows: string[][];
  };
}

export class BrandedPDFGenerator {
  private doc: jsPDF;
  private currentPage: number = 1;
  private totalPages: number = 1;
  private currentY: number = 0;
  private readonly pageWidth: number;
  private readonly pageHeight: number;
  private readonly margin: number = 20;
  private readonly headerHeight: number = 35;
  private readonly footerHeight: number = 25;
  private logoImage: string | null = null;

  constructor(orientation: 'portrait' | 'landscape' = 'portrait') {
    this.doc = new jsPDF({
      orientation,
      unit: 'mm',
      format: 'letter'
    });

    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.pageHeight = this.doc.internal.pageSize.getHeight();
    this.currentY = this.headerHeight + 10;
  }

  initialize() {
    this.addHeader();
  }

  async loadLogo(): Promise<void> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.drawImage(img, 0, 0);
          this.logoImage = canvas.toDataURL('image/jpeg');
        }
        resolve();
      };
      img.onerror = () => {
        console.warn('Logo image failed to load, continuing without logo');
        resolve();
      };
      img.src = '/Pearl-Logo-alt.png';
    });
  }

  private addHeader() {
    if (this.logoImage) {
      try {
        const logoWidth = 80;
        const logoHeight = 15;
        const logoX = (this.pageWidth - logoWidth) / 2;

        this.doc.addImage(
          this.logoImage,
          'PNG',
          logoX,
          10,
          logoWidth,
          logoHeight,
          undefined,
          'FAST'
        );
      } catch (error) {
        console.warn('Failed to add logo to PDF:', error);
        this.addTextHeader();
      }
    } else {
      this.addTextHeader();
    }

    this.doc.setDrawColor(37, 99, 235);
    this.doc.setLineWidth(0.5);
    this.doc.line(this.margin, this.headerHeight, this.pageWidth - this.margin, this.headerHeight);
  }

  private addTextHeader() {
    this.doc.setFontSize(18);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(37, 99, 235);
    this.doc.text('PROJECT PEARL', this.pageWidth / 2, 15, { align: 'center' });

    this.doc.setFontSize(9);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(100, 100, 100);
    this.doc.text('Water Quality Monitoring Dashboard', this.pageWidth / 2, 22, { align: 'center' });
  }

  private addFooter(pageNum: number, totalPages: number) {
    const footerY = this.pageHeight - 15;

    this.doc.setDrawColor(200, 200, 200);
    this.doc.setLineWidth(0.3);
    this.doc.line(this.margin, footerY - 5, this.pageWidth - this.margin, footerY - 5);

    this.doc.setFontSize(8);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(100, 100, 100);

    const footerText = 'Generated by Project PEARL -- project-pearl.org | Real-time water quality monitoring';
    this.doc.text(footerText, this.pageWidth / 2, footerY, { align: 'center' });

    const pageText = `Page ${pageNum} of ${totalPages}`;
    this.doc.text(pageText, this.pageWidth - this.margin, footerY, { align: 'right' });
  }

  private checkPageBreak(requiredSpace: number = 15): boolean {
    const availableSpace = this.pageHeight - this.footerHeight - this.currentY;

    if (availableSpace < requiredSpace) {
      this.addNewPage();
      return true;
    }
    return false;
  }

  private addNewPage() {
    this.currentPage++;
    this.doc.addPage();
    this.addHeader();
    this.currentY = this.headerHeight + 10;
  }

  addTitle(title: string) {
    this.checkPageBreak(20);

    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(30, 58, 138);
    this.doc.text(title, this.margin, this.currentY);

    this.currentY += 10;
  }

  addSubtitle(subtitle: string) {
    this.checkPageBreak(15);

    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(51, 65, 85);
    this.doc.text(subtitle, this.margin, this.currentY);

    this.currentY += 8;
  }

  addText(text: string, options: { bold?: boolean; indent?: number; fontSize?: number } = {}) {
    const { bold = false, indent = 0, fontSize = 10 } = options;

    this.doc.setFontSize(fontSize);
    this.doc.setFont('helvetica', bold ? 'bold' : 'normal');
    this.doc.setTextColor(50, 50, 50);

    const maxWidth = this.pageWidth - (2 * this.margin) - indent;
    const lines = this.doc.splitTextToSize(text, maxWidth);

    for (const line of lines) {
      this.checkPageBreak(8);
      this.doc.text(line, this.margin + indent, this.currentY);
      this.currentY += 6;
    }
  }

  addMetadata(label: string, value: string) {
    this.checkPageBreak(8);

    this.doc.setFontSize(9);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(70, 70, 70);
    this.doc.text(`${label}:`, this.margin, this.currentY);

    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(50, 50, 50);
    this.doc.text(value, this.margin + 45, this.currentY);

    this.currentY += 6;
  }

  addSpacer(height: number = 5) {
    this.currentY += height;
    this.checkPageBreak();
  }

  addDivider() {
    this.checkPageBreak(5);

    this.doc.setDrawColor(200, 200, 200);
    this.doc.setLineWidth(0.3);
    this.doc.line(this.margin, this.currentY, this.pageWidth - this.margin, this.currentY);

    this.currentY += 5;
  }

  addTable(headers: string[], rows: string[][], columnWidths?: number[]) {
    const tableWidth = this.pageWidth - (2 * this.margin);
    const numColumns = headers.length;
    const colWidths = columnWidths || Array(numColumns).fill(tableWidth / numColumns);

    this.checkPageBreak(20);

    this.doc.setFillColor(37, 99, 235);
    this.doc.rect(this.margin, this.currentY - 5, tableWidth, 8, 'F');

    this.doc.setFontSize(9);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(255, 255, 255);

    let xPos = this.margin + 2;
    headers.forEach((header, i) => {
      this.doc.text(header, xPos, this.currentY);
      xPos += colWidths[i];
    });

    this.currentY += 5;

    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(50, 50, 50);
    this.doc.setFontSize(8);

    rows.forEach((row, rowIndex) => {
      this.checkPageBreak(8);

      if (rowIndex % 2 === 0) {
        this.doc.setFillColor(245, 247, 250);
        this.doc.rect(this.margin, this.currentY - 4, tableWidth, 7, 'F');
      }

      xPos = this.margin + 2;
      row.forEach((cell, i) => {
        const cellText = this.doc.splitTextToSize(String(cell), colWidths[i] - 4);
        this.doc.text(cellText[0] || '', xPos, this.currentY);
        xPos += colWidths[i];
      });

      this.currentY += 6;
    });

    this.currentY += 3;
  }

  addSection(section: PDFContentSection) {
    if (section.title) {
      this.addSubtitle(section.title);
    }

    section.content.forEach(text => {
      this.addText(text);
    });

    if (section.table) {
      this.addSpacer(3);
      this.addTable(section.table.headers, section.table.rows);
    }

    this.addSpacer(5);
  }

  finalize(): jsPDF {
    this.totalPages = this.currentPage;

    for (let i = 1; i <= this.totalPages; i++) {
      this.doc.setPage(i);
      this.addFooter(i, this.totalPages);
    }

    return this.doc;
  }

  download(filename: string) {
    const finalDoc = this.finalize();
    finalDoc.save(filename);
  }

  getBlob(): Blob {
    const finalDoc = this.finalize();
    return finalDoc.output('blob');
  }
}

export async function createBrandedPDF(
  title: string,
  sections: PDFContentSection[],
  orientation: 'portrait' | 'landscape' = 'portrait'
): Promise<BrandedPDFGenerator> {
  const pdf = new BrandedPDFGenerator(orientation);
  await pdf.loadLogo();
  pdf.initialize();

  pdf.addTitle(title);
  pdf.addSpacer(5);

  sections.forEach(section => {
    pdf.addSection(section);
  });

  return pdf;
}
